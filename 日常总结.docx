2018.7.2
熟悉工作环境，申请工作权限，阅读相关资料，了解工作任务。
2018.7.3
安装idea、vs等必用软件。了解fourinone框架的特点，阅读fourinone有关资料，查找c++与Java混合编程 Java Native Interface相关的知识。Fourinone开源demo工程运行不起来，寻找解决方法。
2018.7.4
成功用Interij Idea编译程序，参考相关资料，运行fourinone上手demo程序。
2018.7.5
和余勇超导师讨论，重新理解原框架代码的参数和含义，分析每一部分容易出问题的点。
详细阅读fourinone上手demo代码，理解fourinone上手demo的基本概念，包括工头、工人、职介所。
继续编译fourinone完整demo代码程序，并在同台机器上运行，理解其运行原理，如何分配任务、实现任务拆分和计算结果合并，以及工头链式处理等等。

2018.7.9
成功运行fourinone框架的 Demo3 工人合并互相say hello的示例、Demo4 实现Hadoop经典实例Word Count、Demo5 分布式多机部署的示例，并阅读理解代码。了解到集群计算节点之间互相交互，以及工头批量处理和工人互相传递数据（多用于合并）等功能，演示了Hadoop的经典实例Word Count的实现。利用余勇超导师提供给我的四台linux服务器，分别安装了java，并实现了多机运行示例代码。
2018.7.10
运行Demo6 分布式计算自动部署的示例代码，Fourinone可以支持自动化class和jar包部署，class和jar包只需放在工头机器上，各工人机器会自动获取并执行，兼容操作系统，不需要进行安全密钥复杂配置。运行Demo7 计算过程中的故障和容灾处理，如果工人在计算过程中发生故障，框架会进行截获，然后提前返回计算结果，并设置结果的状态为异常。但是运行结果显示出异常，结果设置却未显示异常。正在研究输出结果与预想不同的原因。
本地运行Hadoop经典实例Word Count，测试用例为600M左右的单词文档，分配给本地两个worker运行，运行时间614s，成功运行得到正确结果。运用分布式多机部署的方式运行，两台机器测试用例600M*2，运行时间为113s，成功得到正确运行结果。Fourinone成功通过基础压力测试。
2018.7.11
继续研究Fourinone。解决昨天运行Demo7 计算过程中的故障和容灾处理出现的框架截获异常失败的问题，成功运行代码。运行Demo9 计算过程中的相关时间属性设置，理解config.xml中heartbeat心跳时间设置和maxdelay抢救时间设置的概念。运行Demo10 如何在一台计算机上一次性启动多个进程，学会用一台机器启动多个进程，包括串行、并行启动，直接杀死进程和超时杀死进程，和日志输出。并基于此，分别在本地win机器和一台服务器Linux上完成say hello任务，将相关日志输出保存。在多台服务器上尝试一次性启动多个进程，出现Ctor无法连接分机服务器的问题，还在研究怎么解决。
重新进行分布式多机部署压力测试，这次依旧是两台服务器用于运算，但每台服务器上开启多个worker，每台机器上inputdata任务大小约为600M，运行时间为492s，成功得到正确运行结果。
2018.7.12
上午与超哥讨论，调整研究思路，将工作重点放在了解fourinone的任务调度和内存存取两个方面上。执行Demo11 分布式缓存demo，了解key-value的缓存存储模式。部署过程中出现很多问题，已经逐一解决。总结出现的问题和解决方法，以免之后的操作中再出现类似错误。理解一致性哈希算法的原理、改进和实现，为进一步了解fourinone的任意扩容概念做准备。
总结：每个CacheServer、ParkServer、CacheFacade必须在物理上独自享有一台机器。否则会出现地址被占用的报错；关于CacheFacade的配置，config.xml中，应该注意CACHEGROUP所对应的starttime日期。只有当天日期所在的日期范围内的CacheGroup中的server会被调用；如果有多个CacheFacade，要保持所有config.xml的CACHEGROUP信息一致；对于Linux平台，config.xml中的日期格式改为“YYYYMMDD”，否则会抛出异常。而Win平台上，保持原本的“YYYY-MM-DD”格式即可；如果cachePutDemo在执行过程中因为个人操作出现错误，应当重启所有Server重新部署，否则cacheGetDemo将一直得不到结果；强行中断CacheFacadeServer之后，不能在其窗口直接再次执行CacheFacadeDemo，否则会出现address被占用的情况。必须重启所有server窗口。
2018.7.13
了解了fourinone任意扩容的概念，以及缓存容量相关设置、缓存清空相关属性设置的内容。进一步熟悉分布式协调相关功能，多机部署运行Demo17 统一配置管理demo，代码内容包括如何实时获得节点更新信息，以及在主机（master）宕机的情况下，切换至备用服务器（slave）并保持数据功能稳定的效果。运行Demo18 分布式锁Demo、Demo19 集群管理demo和Demo21 计算中止demo，理解领导者选举相关属性设置（config中的alwaystryleader）。基本了解fourinone架构的各种功能，可以满足任务调度和内存存取功能，暂定fourinone框架为替换框架。在导师余勇超的提醒下，发现自己对于分布式框架的性能、压力测试等详细概念依旧很薄弱。在网上下载《Fourinone分布式计算框架性能、压力、容灾测试报告》，计划学习并借鉴其相关测试内容，进一步了解分布式框架测试相关的概念，重点了解该测试报告中fourinone框架的缺点，分析这些不足我们能否接受。进一步确保框架的敲定有据可依。
此外，阅读原来的代码框架，一边了解功能流程，一边学习C++语法，争取尽快理解原版代码的含义和功能。
下一周开始，全面了解fourinone的缺点，尽快确定自己的能力和任务的要求能否承受
研究如何将这个框架与原来的代码相结合。

2018.7.16
开始适配代码，研究网上C++工程调用Java程序的例子，因为不熟悉C++，正在尽快熟悉vs工程，暂未实现网上例子复现。此外，根据网上下载的《Fourinone分布式计算框架性能、压力、容灾测试报告》，再次对fourinone测试，测试一：进行WordCount多机单实例和多机多实例的对比测试，结果如下；测试二：进行计算节点满负荷长时间运行的压力测试，运行10小时，看是否出现异常（修改代码，输出每个工人一次计算的单个耗时时长），结果要明天才能统计。
机器数量	每台机器实例数量	每个实例处理的数据量	总的处理数据量	测试结果1	测试结果2	测试结果3	测试结果4	测试平均时间
2	2	1G	4G	218s	222s	214s	223s	219.25s
1	8	512M	4G	201s	225s	376s	231s	258.25s
2	8	256M	4G	151s	180s	156s	151s	159.5s
2	4	512M	4G	180s	167s	183s	202s	183s

FourInone不提供异常处理，所有异常需要开发人员自己处理
因此要注意处理单个工作节点抛出异常 和 单个工作节点网络断开异常
67108864
计算节点满负荷长时间运行
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率	测试结果
1	8	512M	3s	10:11:10???
2	2	1G	3s	15:27-23:06:19
Out of memory (机器1)
详见hs_err_pid103309.log
2	4	512M	3s	8:53:37-9:46:28
详见hs_err_pid114763.log
Replay_pid114763.log
2	2	1G	120s+1200s	16:40:09-8:42(成功)
2	8	256M	15s	
2	8	256M	60s	
1	8	512M	120s	10:33:05
57467s
 
2-2-1g-3s
 

2-4-512-3s
 
 

//很多图片异常的信息没有复制过来，都是outofmemory
 


szvpstar100024:~/zhangxilai/wordCount # java -cp fourinone.jar: WordcountWK 2008Jul 17, 2018 9:59:11 AM  
INFO: getLeaderPark...................
Jul 17, 2018 9:59:11 AM  
INFO: leader server is(10.162.203.95:1888)
Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00007fa8ea637000, 262144, 0) failed; error='Cannot allocate memory' (errno=12)
#
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 262144 bytes for committing reserved memory.
# An error report file with more information is saved as:
# /root/zhangxilai/wordCount/hs_err_pid2383.log


2018.7.17
首先总结昨天进行的计算节点满负荷长时间运行测试的测试结果。如下图可知，无论机器数量和每台机器实例大小如何，初始化的Heartbeat参数=3s下长时间运行，ParkServer会因为不能及时得到worker的回应而默认worker失联，最终导致异常。将heartbeat调整，修改为120s，程序在满负荷执行5个多小时之后报出异常。继续尝试如何调整参数，能成功长时间高负荷运行。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
1	8	512M	3s	10:11:10—error
2	2	1G	3s	15:27-23:06:19(8h error)
2	4	512M	3s	8:53:37-9:46:28(1h error)
1	8	512M	120s	10:33:05-15:45:32(error)
2	2	1G	120s+1200s	运行中
此外，根据网上资料，利用JNI（Java Native Interface）成功执行C++调用Java类中方法，包括创建虚拟机，执行并销毁的过程，并详细理解其中代码含义和作用。与余勇超导师讨论，计划先编写一个模拟程序，模型实现跨平台调用、任务分配与执行等功能。整个流程完全与要修改的原代码流程相同。分析模拟程序模型流程，考虑其中难点。明日起开始编写模拟程序。




 
 
 
 
 
 

 
2018.7.18
机器数量为2，每台机器两个实例，每个实例处理数据量为1G的情况下，成功满负荷运行16小时并输出正确结果。总结之前运行出现的问题，发现报错信息为机器内存不足，尝试调整config，使得过期数据定时清空，继续进行下一测试。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
1	8	512M	3s	10:11:10—error
2	2	1G	3s	15:27-23:06:19(8h error)
2	4	512M	3s	8:53:37-9:46:28(1h error)
1	8	512M	120s	10:33:05-15:45:32(error)
2	2	1G	120s+1200s	16:40:09-8:50，共计58063s，约16h ，执行结果正确。(成功)
2	4	512M	120s+1200s
expiration=0.15h=540s
clearperiod=0.08h=288s	运行中
此外，编写模拟模型代码，完成虚拟机环境创建、创建模拟数据、启动CacheServer、启动ParkServer的代码。关于下面的缓存部分代码，由于一开始没有详细的设计好每一步，关于哪一步用C++写，哪一步用Java写，都是临时决定的，导致了编写部分代码之后，发现设计的交互格式不合理。因此已修改结构，开始重写代码。




由于worker的IP地址设置错误，导致每次机器只调用了一台机器实例上的接口（212.177），而另一台机器没有进入测试。因此之前测试的所有结果都有问题，全部都是一台机器上的实例调用，不能作为参考依据。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
2	2	1G	120s+1200s	16:40:09-8:50，共计58063s，约16h (成功)
2	4	512M	120s+1200s
expiration=0.15h=540s
clearperiod=0.08h=288s	17:51:08-00:33:45，6h42min error
2	4	512M	120s+1200s
expiration=0.02h=72s
clearperiod=0.01h=36s	8:58:53-9:44:00（2647s） error
由于IP地址设置错误，上面的数据全部失效。
2	4	512M	120s+1200s
expiration=0.15h=540s
clearperiod=0.08h=288s	11:05:40-2:59:52 error
2	4	512M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	运行中（10:48:14-
2	3	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	等待
 

2018.7.19
关于测试的问题，修改expiration参数后，程序执行6个多小时之后依旧出现异常。修改代码，添加自动获取抛出异常机制，看看能否解决无法持续运行10小时的问题。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
2	2	1G	120s+1200s	16:40:09-8:50，共计58063s，约16h (成功)
2	4	512M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s	17:51:08-00:33:45，6h42min error
以下为添加异常处理之后的测试结果。
2	4	512M	120s+1200s expiration=0.15h=540sclearperiod=0.08h=288s	14:05:40-17:59:52 error
修改代码之后仍然只运行了4个小时，代码获取到212.177机器Out of memory异常，但是没有继续doTask，明天研究一下是哪里修改的不对。
继续编写模拟模型代码，完成config配置，启动CacheFacadeServer，实现写入cache的一部分代码。阅读理解fourinone.jar内封装的源代码，正在研究如何更合理写入cache。

2018.7.20
继续进行压力测试，修改了异常处理机制，程序持续运行中。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
2	2	1G	120s+1200s	【旧】16:40:09-8:50，共计58063s，约16h (成功)
2	4	512M	略	【旧】error
2	4	512M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	运行中（已执行3个小时）
2	3	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	等待
继续编写模拟模型代码，完成了把内存写入cache、启动多个Worker实例、启动工头、工头根据key分配task给工人、工人通过key读取cache中的数据、工人执行任务Java代码、工人执行任务C++代码、工人从Java平台调用C++平台代码，并返回结果给工头、工头统计任务结果。接下来还需实现的功能有：工头将结果存储进cache，返回key数组给C++。实现全部代码后，即可开始调试模拟模型。

2018.07.23
上午参加了新员工培训。加入容错机制的fourinone在运行8个小时之后出现了异常。我在网上查阅了相关的测试资料，有人提到fourinone在四实例情况下长时间运行会出现不稳定的状况，具体Parker显示计算节点脱离，与我的测试效果相同。这个网上的测试报告还提到，该异常情况只在四实例的情况下出现，三实例和单实例情况下运行正常，也与我的测试只有运行2实例能正常工作的测试结果相符。报告中没有找到出现这种异常的具体原因。因此我计划再测试一下每台机器3实例的情况，看fourinone能否满负荷运行10小时以上。该测试已在执行中。 
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
2	2	1G	120s+1200s	【旧】16:40:09-8:50，共计58063s，约16h (成功)
2	4	512M	略	【旧】error
2	4	512M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	14:39:50-22:38:50（运行8小时，出现error）
2	3	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	11:16:14-19:21:50，运行8个小时，出现error。
3	3	455M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	运行中（9:40:43-
3	2	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	等待
此外，编写完成了模拟模型，调试过程中发现无法用C++调用Java启动Server。注释掉Java中启动Server的语句，C++可以正常调用Java代码；而直接用Java命令调用该Java接口也能正常启动Server并输出log。并且C++也可以正常调用Java代码中fourinone package内部的非启动Server代码。因此判断程序异常与C++调用Java启动server相关。在网上找不到相关问题的解决方法，又咨询了w3平台上比较熟悉JNI的前辈，暂时没有找到解决方法。不知道武研这边有没有对JNI熟悉的人，计划明天再研究如何解决这个问题。

2018.7.24
8:30
统计测试结果。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
2	3	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	11:16:14-19:21:50，运行8个小时，出现error。
9:00
创建新的大小的测试数据文档，继续尝试以下测试实验。
3	3	455M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	运行中（9:40:43-
3	2	683M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	等待
10:00
将C++调用1.7版本JDK改为调用1.8版本JDK，跨平台调用程序出现问题，JVM无法启动。
经试验，排除Java工程配置错误导致出现该问题的可能；
经试验，排除C++代码编写失误导致出现该问题的可能；
11:00
考虑可能是我安装的JDK1.8的版本本身有问题。再次安装另外两个版本的JDK1.8。
11:20
确认是旧版本的JDK1.8有问题，采用新版本中的JDK1.8.0_45可以成功启动ParkServer。因为linux服务器上正在运行测试数据，程序没有执行到结束。但是以显示server启动流程，并输出 address already in use：bind。
2:00
发现压力测试程序出现异常，输出的错误日志仍显示与Out of memory相关的问题。考虑进一步加快内存清空频率。
3	3	455M	120s+1200sexpiration=0.15h=540sclearperiod=0.08h=288s（有容错机制）	（9:40:43-12:27:07）运行3小时后出现error。
3	2	683M	120s+1200sexpiration=0.08h=288sclearperiod=0.01h=36s（有容错机制）	等待
2:30
由于压力测试停止，可以使用linux服务器进行模拟代码测试。
3:41
出现server创建时无法连接和address占用的问题。怀疑需要在linux服务器上执行模拟程序，开始研究如何在Linux平台上运行C++代码。
4:00
发现本地执行demo代码也会出现address already in use：bind的问题。估计是安装新的JDK1.8之后，JDK的环境配置变量发生了什么问题，导致本地Server无法启动。
4:11
将JDK配置好，仍然不能运行。
4:30
找到问题原因，因为C++代码中执行Server启动服务，却没有在程序结束时断开，导致address长时间被占用，再次运行程序依旧报错。将所有运行程序关闭，重启云桌面，才解决这个问题。
4:41
上述问题应该是因为程序完善之前，未在异常处理时执行虚拟机销毁程序导致。现加入这段代码，已经不再出现地址被占用的问题。
4:46
研究connect问题是否因为一个命令窗口执行多个程序导致。
5:16
确认connect问题是因为一个命令窗口执行多个程序导致。之前尝试使用fourinone中提供的一次性启动多个程序的接口，但是出现虚拟机启用相关问题。研究一下怎么解决。
6:04
总结接下来要解决的问题：
1.	模拟程序在执行一次性启动多进程时，日志出现无法加载类的情况，Demo程序没有这个问题。寻找解决方法。
2.	研究C++程序如何在linux平台上执行，将模拟代码移动到Linux平台执行。
6:33
继续执行fourinone压力测试，缩短expiration和clearperiod，明天上午检查运行结果。
3	2	683M	120s+1200sexpiration=0.08h=288sclearperiod=0.01h=36s（有容错机制）	运行中（6:33:36-

2018.7.25
8:30
参加新员工培训会议，学习入门篇波分技术。
11:14
会议结束，检查fourinone压力测试运行情况。运行结果正常。推断运行结果正常的原因可能有：1.每台机器两实例，而非3或4实例，因而计算正常；2.缩短了expiration和clearperiod，因此计算正常。计划接下来进行三实例对比测试，看看能否成功。
机器数量	每台机器实例数量	每个实例处理的数据量	心跳频率+maxdelay	测试结果
3	2	683M	120s+1200sexpiration=0.08h=288sclearperiod=0.01h=36s（有容错机制）	运行中（6:33:36-11:20:23），共60052s = 16.68小时。持续运行，满足压力测试。
2	3	683M	120s+1200sexpiration=0.08h=288sclearperiod=0.01h=36s（有容错机制）	运行中（11:28:50-
11:30
开始处理昨天的遗留问题一：模拟程序在执行一次性启动多进程时，日志出现无法加载类的情况，Demo程序没有这个问题。寻找解决方法。
排除Java代码中路径参数错误情况； 
排除非静态函数调用静态函数导致无法读取类的问题的情况；
14:18
三实例的压力测试再次出现异常。因此建议在还没有找到如何人工处理out of memory异常之前，fourinone尽量在2实例状态下执行计算任务。
2	3	683M	120s+1200sexpiration=0.08h=288sclearperiod=0.01h=36s（有容错机制）	（11:28:50-12:53:51）运行4917s，约一个半小时。
异常日志：
Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00007fd0bb2de000, 12288, 0) failed; error='Cannot allocate memory' (errno=12)
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 12288 bytes for committing reserved memory.
14:46
考虑问题一原因可能为：C++调用Java静态函数和非静态函数需要用的callmethod函数不同，开始修改代码。
15:18
判断失败，问题一并非由静态函数导致。依旧无法加载类。
15:44
考虑问题一原因为：在Java jar包中再调用Java jar包，导致程序无法运行。
研究如何使用IDEA导出包含引用第三方jar包的可运行jar包，看看能不能解决这个问题。
17:01
不是简单的调用第三方jar包的问题。考虑是Java代码中直接调用了fourinone中BeanContext.tryStart()函数启动多个进程导致。应该需要阅读源码，理解它是如何启动进程并保存日志的，才能弄清楚问题到底出在哪里。
开始阅读这部分fourinone源码。
18:11
暂时没有定位到出问题的源码的位置，明天继续。
需要解决的问题总结：
1.	解决C++调用jar包无法一次性启动Java多个进程的问题。
2.	研究C++程序如何在linux平台上执行，将模拟代码移动到Linux平台执行。
3.	现阶段压力测试只能满足两进程的测试，如何解决三进程的Out Of Memory的问题？内存占用过多的情况是因为什么而出现的？如何通过人工编写代码，处理掉异常并重新计算该部分的任务？
 
2018.7.26
8:30
继续解决C++调用jar包无法一次性启动Java多个进程的问题。阅读源码，考虑可能与Java中的ProcessBuilder有关。
9:54
写了一个demo，验证Java平台调用jar包时，可以启用ProcessBuilder。
10:11
与余勇超导师讨论，导师建议不要把所有的启动都放在代码里面，可以先直接在环境上启动，代码里面只下发任务。之后再考虑如何自动化。
C++调用jar包无法一次性启动Java多个进程的问题优先级降低。接下来的任务是将启动程序单独摘出来，重新设计代码结构，并将代码在Win平台和Linux平台上运行。
10:45
重新确定代码构架。
程序步骤	需要准备的文件	机器IP
创建jvm虚拟环境	C++总体工程	机器X
启动CacheServer	一个Java class（IP端口信息在代码中配置） 	10.162.212.177:2000, 10.162.212.177:2001
启动ParkServer	一个Java class，以及对应的config文件	10.162.203.95:1888，10.162.203.95:1889
启动CacheFacadeServer	一个Java class，以及对应的config文件	10.162.235.205:1998，
//10.162.235.205:1999
启动Worker*2	一个Java class	10.162.212.236:2008，10.162.212.236:2009
一个机器上两个实例，端口号需要在启动class程序时手动输入
Ctor	创建模拟数据WordCount	一个C++总体工程，一个C++ doTask程序，一个Java jar包实现Ctor，被C++总体工程调用。	机器X
	将data传入cache得到key[]		
	分配任务，并将对应key传给对应worker		
	得到worker计算结果，统计并保存进cache。		
（验证）从cache取出结果，并输出显示，检验功能是否正常	在Java jar包内实现。	机器X
销毁JVM，释放资源	C++总体工程	机器X
其中，机器X为四台机器中的任意一个。保证所有代码位于同一个机器X即可。
16:34
完成模拟代码结构修改。
17:11
数据量过大，会出现string转jstring失败的问题。
18:20
未解决数据量过大，会出现string转jstring失败的问题，计划采用ByteArray数组传输解决此问题。
2018.7.27
8:30
参加新员工培训会议。
10:20
会议结束，开始解决昨天的遗留问题。
问题一：数据量过大，会出现string转jstring失败的问题
问题二：研究C++程序如何在linux平台上执行，将模拟代码移动到Linux平台执行。
14:39
512M的String数据量过大，已经采用拆分成数组的方式传输。原工程的参数也可以考虑用这种方法。问题一解决。
15:00
检验doTask函数的功能是否可用，发现有问题。
15:41
修改完成，调通Java调用C++的doTask函数代码。
接下来处理问题二，划分为三个子问题：
1.	研究如何在linux平台上执行C++工程。
2.	考虑C++工程在Linux上创建虚拟机时对应的JDK配置
3.	考虑Java的jar包通过dll实现Java调用C++，二次打包会不会对调用有影响？dll路径在Linux平台上需要进行的系统设置有哪些？
16:27
学习完成，如何在Linux上运行C++工程；下一步研究如何在Linux上实现C++工程调用Java代码。
16:54
发现Linux上C++调用Java的代码和Win上C++调用Java的代码有点不一样，需要修改代码。
17:41
尝试在Linux上执行C++代码，编译器报错，显示中英文编码乱码，研究如何解决。
17:57
发现忘记条换jni.h文件，下周继续修改。

2018.7.30
一、困难与求助
Linux平台上编译C++工程进展缓慢，经过导师的指点，有了新进展。编译发现无法从jni.h头文件中调用函数方法，明天解决这个问题。
二、任务进展
	今日计划完成的工作方向有：
参加新员工培训会议；编写实习生管理系统月度总结；在Linux平台上运行C++工程；在Linux平台上用C++调用Java；
	今日已经完成的工作有：
参加新员工培训会议，了解产品级敏捷流程介绍。
完成实习生月度总结。
尝试使用VS2017，直接进行Linux交叉编译，程序仍然出现报错的问题。与导师余勇超交流，纠正我的学习方向，开始研究如何利用makefile文件编译程序，并一边执行makefile一边修改代码报错。
三、体会和总结
许多操作比如在Linux平台上用C++调用Java和在Win平台上的操作不同，并不能通过直接移植代码实现。最一开始研究这部分工作时就应该直接针对Linux平台编写代码，现在把Win调通却不能在Linux上面执行，要重新修改代码，有点浪费时间。进展缓慢时要多请教导师，可以达到事半功倍的效果。
四、下一步计划
写好makefile，执行模拟代码。
2018.07.31
一、困难与求助
代码在执行结束之后，无法执行DestroyJavaJVM，尚不清楚原因是什么。
二、任务进展
	今日计划完成的工作方向有：
写好makefile，执行模拟代码。
	今日已经完成的工作有：
成功编译模拟代码并执行，已得到正确结果。其中用于计算的机器数量为1，每台机器上的实例数量为2，每个实例处理的数据量为1G。执行长时间满负荷运行压力测试，程序运行中。
三、体会和总结
四、下一步计划
阅读原工程代码，开始框架适配工作。
2018.8.1
一、任务进展
	今日计划完成的工作方向有：
参加新员工培训会议；
检查模拟代码压力测试结果；
阅读原工程代码，开始正式框架适配工作；
	今日已完成的工作有：
参加新员工培训会议，熟悉isource的使用，Devops开发环境和云龙调试方式。
模拟代码压力测试正常，满负荷运行时长17:15-10:20，共17小时，满足长时间运行条件。
拿到原工程代码并阅读，进一步熟悉原代码流程，确定修改定点。
二、尚未解决的问题
	固有问题：
代码在执行结束之后，无法执行DestroyJavaJVM，尚不清楚原因是什么。
每台机器实例在3个或3个以上时，无法承担10小时长时间满负荷运行。网上有关fourinone的测试报告也显示过类似问题。尚未找到解决方法。
	新增问题（重点解决）：
对原代码流程定点缓慢，代码不容易看懂，需要加快阅读原代码的速度，尽快开始修改。
三、下一步计划
与导师讨论，进一步对需要计算的数据类型进行更清晰的理解。对数据理解之后，开始修改代码。

框架适配工作包括：
熟悉原工程代码，先将原工程代码编译运行。
主程序：wdmsimulation（开始工作），，，multiprocess_survival_mgr.cpp，包括一个回滚操作，看看怎么改
子程序：wdmsimprocess（任务执行），，，
找到需要修改的部分，看看原来的liteTask框架是怎么执行的，修改为我的代码。


2018.8.2
一、任务进展
	今日计划完成的工作方向有：
解决昨日新增问题，阅读原工程代码，理解每一步需要改和不需要改的地方；
确定修改步骤，开始代码修改；
	今日已完成的工作有：
充分理解有关代码，以及代码中各个字段的含义。
确定修改步骤，开始修改代码，已完成大约1/3。
二、尚未解决的问题
	固有问题：
模拟代码在执行结束之后，无法执行DestroyJavaJVM，尚不清楚原因是什么。
每台机器实例在3个或3个以上时，无法承担10小时长时间满负荷运行。网上有关fourinone的测试报告也显示过类似问题。尚未找到解决方法。
	新增问题（重点解决）：
尚未解决用于运行程序的模拟数据等问题，无法通过运行程序查看修改结果。
存储程序的服务器10.188.244.140仍然无法登陆。
还不能理解代码最终返回的数据类型为task_out_data的out_data是如何从out_id（key）转换而来的？
三、下一步计划
与导师讨论，解决上述新增问题，并继续完成代码适配。



2018.8.3
一、任务进展
	今日计划完成的工作方向有：
参加新员工培训会议；
解决昨日新增问题；
继续完成代码修改；
	今日已完成的工作有：
参与新员工培训会议，了解NetStar Plan产品定位和进行简单网络设计与规划的步骤。
完成大部分代码适配，接下来需要一边编译运行一边修改。
存储程序的服务器10.188.244.140仍然无法登陆。导师将更换存储程序的服务器。
二、尚未解决的问题
	固有问题：
模拟代码在执行结束之后，无法执行DestroyJavaJVM，尚不清楚原因是什么。
每台机器实例在3个或3个以上时，无法承担10小时长时间满负荷运行。网上有关fourinone的测试报告也显示过类似问题。尚未找到解决方法。
	新增问题（重点解决）：
尚未解决用于运行程序的模拟数据等问题，无法通过运行程序查看修改结果。
最终的out_id（key）存储后，还需要执行什么程序得到最终的主程序的返回？
三、下一步计划
在服务器上编译程序，并进一步修改出现的问题。与导师讨论，解决上述新增问题。
 
2018.8.6
一、任务进展
	今日计划完成的工作方向有：
参加新员工培训会议；
解决新增问题；
在服务器上编译程序，进一步完成代码修改；
	今日已完成的工作有：
参与新员工培训会议，了解NetStar-View的产品定位、价值，熟悉NetStar-View的基本功能，理解波分Refarming的使用过程。
解决上周遇到的新增问题，主程序最终得到outdata返回是通过回调函数。估计程序运行时可能出现的状况，并分析解决方案。
按计划修改程序makefile，但程序makefile有点复杂，尚未修改成功。
二、尚未解决的问题
	固有问题：
模拟代码在执行结束之后，无法执行DestroyJavaJVM，尚不清楚原因是什么。
每台机器实例在3个或3个以上时，无法承担10小时长时间满负荷运行。网上有关fourinone的测试报告也显示过类似问题。尚未找到解决方法。
	新增问题（重点解决）：
解决编译问题；
运行程序，检查代码是否可以运行。
三、下一步计划
深入业务，进一步调整代码。找到编译和运行的方法。


 
这个是干嘛的？
1.	lst_task_uuid回溯是什么概念？
2.	现在在哪个服务器上能编译？
2018.8.8
一、任务进展
	今日计划完成的工作方向有：
参加新员工培训会议；
解决编译和运行的问题；
在服务器上编译程序，进一步完成代码修改；
	今日已完成的工作有：
参与新员工培训会议，了解NetStar-O&M的产品定位、价值，熟悉NetStar-O&M的基本功能，了解6630的工作，包括维护（OD+FD）和光路调通操作。
修改makefile，进行程序编译。编译报错，反序列化操作出现问题。
与导师讨论，了解运行程序的具体操作，以及如何进行功能测试，修改运行config，显示调试日志。
二、尚未解决的问题
	新增问题（重点解决）：
编译出现问题，一直显示某些参数未被声明，不知道是哪里出现了问题；
没弄清运行程序时如何在NetStar模拟上新建故障分析的操作，在编译调通之后需要运行代码时再确认。
三、下一步计划
解决编译上出现的问题。
 
2018.8.9
一、任务进展
	今日计划完成的工作方向有：
解决编译子程序出现的问题；
弄清如何在NetStar模拟故障分析操作；
编译主程序；
运行编译好的程序。
	今日已完成的工作有：
与导师合作，解决业务相关对接而导致的问题。研究Java如何进行C++类成员调用。
下午参加华为实习生交流会。
主程序编译成功。
在导师的帮助下，子程序编译成功。
二、尚未解决的问题
	新增问题（重点解决）：
没弄清运行程序时如何在NetStar模拟上新建故障分析的操作，在编译调通之后需要运行代码时再确认。
三、下一步计划
试运行。

2018.8.13
一、任务进展
	今日计划完成的工作方向有：
参加新员工培训。
程序试运行。
	今日已完成的工作有：
参与新员工培训，学习Java工程开发相关框架有关的基本知识。
试运行程序失败，主程序本身调用不起来。部分编译成功的so文件对应的动态链接库显示not found，在余勇超导师帮助下找到相关原因，准备进行进一步调试。
二、下一步计划
解决试运行中遇到的问题。

2018.8.14
一、任务进展
	今日计划完成的工作方向有：
程序试运行，解决运行过程中出现的问题。
	今日已完成的工作有：
JNI无法创建虚拟机。
怀疑是编译成.so之后更换服务器平台导致配置问题。对模拟代码进行试验，将模拟代码编译生成文件.o直接复制到另一台服务器上，并运行。出现无法找到libjvm.so报错。在网上查找相关解决方案，并修改配置。模拟代码运行正常。同样的方法修改工程代码，仍然JNI_CreateJavaVM函数仍然无法执行。
考虑可能是后缀不同，所以运行配置方式不同。将模拟代码编译成.so文件，依旧可以执行。因此排除这种可能性。
对JNI_CreateJavaVM函数进行try catch捕捉异常，程序依旧卡在这个函数无法返回状态值。
尚未找到解决方法。
二、下一步计划
希望能找到JNI相关领域的大神探讨一下，继续解决试运行中遇到的问题。

2018.8.15
一、任务进展
	今日计划完成的工作方向有：
程序试运行，解决运行过程中出现的问题。
	今日已完成的工作有：
参加新员工培训，学习Java开发调试技巧。
发现10.162.60.127的Java环境配置出现问题，重新配置jdk，Java环境搭建成功，但依旧没有解决JNI_CreateJavaVM的问题。
JNI无法创建虚拟机。
怀疑是编译成.so之后更换服务器平台导致配置问题。对模拟代码进行试验，将模拟代码编译生成文件.o直接复制到另一台服务器上，并运行。出现无法找到libjvm.so报错。在网上查找相关解决方案，并修改配置。模拟代码运行正常。同样的方法修改工程代码，仍然JNI_CreateJavaVM函数仍然无法执行。
考虑可能是后缀不同，所以运行配置方式不同。将模拟代码编译成.so文件，依旧可以执行。因此排除这种可能性。
对JNI_CreateJavaVM函数进行try catch捕捉异常，程序依旧卡在这个函数无法返回状态值。
尚未找到解决方法。
二、下一步计划
希望能找到JNI相关领域的大神探讨一下，继续解决试运行中遇到的问题。

